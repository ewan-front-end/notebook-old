<!DOCTYPE html>
<html>
<head><title>正则表达式测试</title></head>
<body></body>
</html>
<script>







var str = `B1$1111a

%111111a
B$111111
B&bbbbba
B1s1111a
22221111`
var m = str.match(/^(((?=.*[a-z])(?=.*[A-Z])(?=.*\d))|((?=.*[a-z])(?=.*[A-Z])(?=.*[@!%&\$\*\?]))|((?=.*[a-z])(?=.*\d)(?=.*[@!%&\$\*\?]))|((?=.*[A-Z])(?=.*\d)(?=.*[@!%&\$\*\?])))[A-Za-z\d@!%&\$\*\?]{8,}$/mg)
console.log(m);











    
    var content = 
    `
    ----------
    0[13-19](bold C1a1 18PX)
    1[13-19](bold C1a1 18PX)
    ----------2
    `
    

    /* 正则方法: 对整体内容依次处理匹配 */
    let matchBlock
    while ((matchBlock = /^-{10}[\r\n]{1,2}([\s\S]+?)^-{10}(\d{1,2})?[\r\n]{1,2}/m.exec(content)) !== null) {
        content = content.replace(matchBlock[0], 'STYLEBLOCK\n') // 注：匹配项必须及时有效被替换，避免再次被匹配
    }

    /* 正则方法: 更简洁的方法 */
    while (/^\s*(-\s([^\n\r]+))/m.exec(content) !== null) {content = content.replace(RegExp.$1, `<span>● ${RegExp.$2}</span>`)}

    /* 字符串方法: 一次性匹配结果集再遍历, 没有死循环的风险 */
    const arr = content.match(/^-{10}[\r\n]{1,2}([\s\S]+?)^-{10}(\d{1,2})?[\r\n]{1,2}/gm) || [];
    arr.forEach((e) => { console.log(e) })
</script>